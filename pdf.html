<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NuvexPDF - éƒ¨ç½²ä¿®å¾©ç‰ˆ</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

    <style>
        .loader { border: 3px solid #f3f3f3; border-top: 3px solid #3b82f6; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .dragging-source { opacity: 0.4; background: #f3f4f6; border: 2px dashed #9ca3af; }
        .drag-target-hover { transform: scale(1.05); box-shadow: 0 0 0 3px #3b82f6 !important; background-color: #eff6ff !important; z-index: 10; position: relative; }
        .sidebar-insert-hover { transform: scale(1.02); box-shadow: -4px 0 0 0 #10b981, 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important; background-color: #ecfdf5 !important; z-index: 20; }
        
        .draggable-item { cursor: grab; transition: transform 0.2s; }
        .draggable-item:active { cursor: grabbing; }
        .page-card { cursor: grab; transition: transform 0.2s, box-shadow 0.2s; }
        .page-card:active { cursor: grabbing; }
        .sidebar-item { cursor: grab; transition: all 0.2s; }
        .sidebar-item:active { cursor: grabbing; }
        
        .drag-over-zone { background-color: #eff6ff !important; border-color: #3b82f6 !important; transform: scale(1.01); }
        #editor-drop-overlay { background-color: rgba(255, 255, 255, 0.9); border: 4px dashed #3b82f6; pointer-events: none; z-index: 50; }
        .sidebar-target-hover { border-color: #3b82f6 !important; background-color: #eff6ff !important; transform: translateX(5px); }
    </style>
</head>
<body class="bg-slate-100 min-h-screen font-sans text-slate-800">

    <div id="system-error-banner" class="hidden bg-red-600 text-white p-4 text-center font-bold sticky top-0 z-50 shadow-lg">
        <i class="fas fa-exclamation-triangle mr-2"></i> æ ¸å¿ƒçµ„ä»¶è¼‰å…¥å¤±æ•—ï¼è«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–é‡æ–°æ•´ç†é é¢ã€‚
    </div>

    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <div class="text-center mb-8">
            <h1 class="text-3xl font-extrabold text-slate-800 mb-2"><span class="text-blue-600">Nuvex</span>PDF</h1>
            <p class="text-slate-500 text-sm">éƒ¨ç½²ä¿®å¾©ç‰ˆ â€¢ ç©©å®šæ ¸å¿ƒ</p>
        </div>

        <div class="bg-white rounded-xl shadow-xl overflow-hidden min-h-[500px]">
            <div class="flex border-b border-gray-100 bg-gray-50 p-4 items-center">
                <i class="fas fa-layer-group text-blue-600 mr-2 text-lg"></i>
                <h2 class="text-lg font-bold text-gray-800">PDF åˆä½µå·¥å…·</h2>
            </div>

            <div class="p-6 md:p-8 relative">
                <div id="section-merge">
                    <div id="drop-zone-merge" class="relative group mb-6">
                        <label class="flex flex-col items-center justify-center w-full h-40 border-2 border-dashed border-slate-300 rounded-xl cursor-pointer bg-slate-50 hover:bg-blue-50 hover:border-blue-400 transition duration-200">
                            <div class="flex flex-col items-center justify-center pt-5 pb-6 pointer-events-none">
                                <i class="fas fa-cloud-upload-alt text-4xl text-blue-500 mb-3"></i>
                                <p class="text-base font-medium text-slate-700">é»æ“Šæˆ–æ‹–æ›³å¤šå€‹æª”æ¡ˆè‡³æ­¤</p>
                                <p class="text-xs text-slate-400 mt-1">æ”¯æ´è‡ªå‹•è§£å¯†èˆ‡é é¢é‡æ’</p>
                            </div>
                            <input type="file" id="merge-input" class="hidden" multiple accept="application/pdf" onchange="handleMergeFiles(this.files)">
                        </label>
                    </div>

                    <div id="merge-ui-container" class="hidden">
                        <div class="flex justify-between items-end mb-4">
                            <h3 class="text-sm font-bold text-slate-700">æª”æ¡ˆåˆ—è¡¨ (<span id="file-count">0</span>)</h3>
                            <span class="text-xs text-blue-500 bg-blue-50 px-2 py-1 rounded select-none animate-pulse">
                                <i class="fas fa-mouse-pointer mr-1"></i> é›™æ“Šå¡ç‰‡å¯åˆªæ¸›æˆ–æ’å…¥é é¢
                            </span>
                        </div>
                        <div id="file-list" class="space-y-3 mb-8"></div>
                        <div class="flex flex-col gap-3">
                            <button onclick="executeMerge()" id="btn-merge" class="w-full py-4 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-bold shadow-lg shadow-blue-200 transition flex justify-center items-center gap-2">
                                <span>é–‹å§‹åˆä½µ PDF</span>
                            </button>
                            <a id="merge-download" href="#" class="hidden w-full py-4 bg-emerald-500 hover:bg-emerald-600 text-white rounded-lg font-bold shadow-lg shadow-emerald-200 transition text-center flex justify-center items-center gap-2">
                                <i class="fas fa-check-circle"></i> <span>ä¸‹è¼‰åˆä½µæª”æ¡ˆ</span>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="text-center mt-8 text-slate-400 text-xs">NuvexPDF Â© 2025</div>
    </div>

    <div id="page-editor-modal" class="fixed inset-0 z-50 hidden bg-gray-900/50 backdrop-blur-sm flex items-center justify-center p-4">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-6xl h-[90vh] flex flex-col relative overflow-hidden">
            <div id="editor-drop-overlay" class="absolute inset-0 hidden flex flex-col items-center justify-center text-blue-500">
                <i class="fas fa-file-import text-6xl mb-4 animate-bounce"></i>
                <p class="text-2xl font-bold bg-white px-6 py-2 rounded-full shadow-lg">æ”¾é–‹ä»¥æ’å…¥é é¢</p>
            </div>
            <div class="flex justify-between items-center p-5 border-b border-gray-100 bg-white z-30">
                <div><h3 class="text-xl font-bold text-slate-800" id="editor-filename">é é¢ç·¨è¼¯å™¨</h3><p class="text-xs text-slate-500"><span class="text-blue-600 font-bold">é›™æ“Š</span>ç§»é™¤ â€¢ æ‹–æ›³æ’åº</p></div>
                <div class="flex gap-2"><button onclick="closeEditor()" class="px-4 py-2 text-slate-500 hover:bg-slate-100 rounded-lg text-sm font-bold">å–æ¶ˆ</button><button id="btn-save-editor" onclick="saveEditorChanges()" class="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm font-bold shadow flex items-center"><span>ç¢ºèªä¿®æ”¹</span></button></div>
            </div>
            <div class="flex-1 flex overflow-hidden relative">
                <div id="modal-scroll-container" class="flex-1 overflow-y-auto p-5 bg-slate-50 relative scroll-smooth">
                    <div id="editor-loading" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-50 z-20 hidden"><div class="loader w-10 h-10 border-4 border-blue-500 mb-4"></div><p class="text-slate-500 font-bold mt-2" id="editor-loading-text">è®€å–ä¸­...</p></div>
                    <div id="page-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 pb-20"></div>
                </div>
                <div class="w-64 bg-white border-l border-gray-200 flex flex-col shadow-lg z-20">
                    <div class="p-3 bg-gray-50 border-b border-gray-200 font-bold text-xs text-gray-500 uppercase tracking-wide flex justify-between items-center"><span>å…¶ä»–å·²ä¸Šå‚³æª”æ¡ˆ</span><i class="fas fa-sort text-gray-300"></i></div>
                    <div id="sidebar-file-list" class="flex-1 overflow-y-auto p-2 space-y-2"></div>
                    <div class="p-3 bg-blue-50 text-xs text-blue-600 text-center border-t border-blue-100">æ‹–æ›³æª”æ¡ˆåˆ°å·¦å´æ’å…¥</div>
                </div>
            </div>
            <div class="p-4 border-t border-gray-100 text-xs text-slate-400 flex justify-between bg-white z-30"><span>ç›®å‰é æ•¸: <b id="editor-page-count" class="text-blue-600">0</b></span><span>éƒ¨ç½²ä¿®å¾©ç‰ˆ</span></div>
        </div>
    </div>

    <script>
        // --- åš´æ ¼éŒ¯èª¤ç›£æ§ ---
        window.onerror = function(message, source, lineno, colno, error) {
            console.error("Global Error:", message);
            // å¿½ç•¥ Tailwind è­¦å‘Šï¼Œå…¶ä»–éŒ¯èª¤å‰‡å½ˆçª—
            if (!message.includes('tailwindcss')) {
                // å¦‚æœæ˜¯ PDFLib ç›¸é—œéŒ¯èª¤ï¼Œé¡¯ç¤ºæ›´å‹å–„çš„è¨Šæ¯
                if (message.includes('PDFLib') || message.includes('pdfjsLib')) {
                    alert("æ ¸å¿ƒçµ„ä»¶åŸ·è¡ŒéŒ¯èª¤ï¼š\n" + message + "\n\nè«‹å˜—è©¦é‡æ–°æ•´ç†é é¢ã€‚");
                }
            }
        };

        // --- Data Model ---
        let mergeFiles = [], currentEditingFileId = null, editorPagesData = []; 
        let isDraggingPage = false, currentMouseY = 0, scrollAnimationId = null, editorDragCounter = 0, imageObserver = null;

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            // 0. æª¢æŸ¥å‡½å¼åº«æ˜¯å¦è¼‰å…¥æˆåŠŸ
            if (typeof PDFLib === 'undefined' || typeof pdfjsLib === 'undefined') {
                document.getElementById('system-error-banner').classList.remove('hidden');
                alert("éŒ¯èª¤ï¼šPDF è™•ç†æ ¸å¿ƒæœªèƒ½è¼‰å…¥ã€‚\nè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šï¼Œæˆ–ç¢ºä¿ GitHub Pages èƒ½å¤ å­˜å– cdnjs.cloudflare.comã€‚");
                return;
            }

            await initPdfWorker();
            setupUploadZone('drop-zone-merge', handleMergeFiles);
            initAutoScroll();
            setupEditorDropZone(); 
            
            imageObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        loadPageThumbnail(parseInt(entry.target.dataset.idx), entry.target);
                        imageObserver.unobserve(entry.target);
                    }
                });
            }, { root: document.getElementById('modal-scroll-container'), rootMargin: "100px" });
        });

        // ğŸ”¥ ä¿®å¾©ï¼šæ›´ç©©å®šçš„ Worker è¼‰å…¥æ©Ÿåˆ¶ ğŸ”¥
        async function initPdfWorker() {
            // è¨­å®š Worker ä¾†æº (ä½¿ç”¨ cdnjs)
            const workerUrl = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            try {
                // å˜—è©¦ç”¨ Blob ç¹é CORS (é€™æ˜¯ GitHub Pages æœ€ç©©çš„æ–¹æ³•)
                const response = await fetch(workerUrl);
                if (!response.ok) throw new Error("Worker fetch failed");
                const blob = new Blob([await response.text()], { type: "text/javascript" });
                pdfjsLib.GlobalWorkerOptions.workerSrc = URL.createObjectURL(blob);
                console.log("PDF Worker initialized via Blob");
            } catch (e) {
                console.warn("Blob worker failed, falling back to URL", e);
                pdfjsLib.GlobalWorkerOptions.workerSrc = workerUrl;
            }
        }

        async function getFileArrayBuffer(fileItem) {
            return fileItem.blob ? await fileItem.blob.arrayBuffer() : await fileItem.file.arrayBuffer();
        }

        async function smartLoadPdf(arrayBuffer, password) {
            const { PDFDocument } = PDFLib;
            try { return await PDFDocument.load(arrayBuffer); } 
            catch (e) {
                if (e.message.includes('encrypted')) {
                    if (password) return await PDFDocument.load(arrayBuffer, { password: password });
                    try { return await PDFDocument.load(arrayBuffer, { password: '' }); } 
                    catch (e2) { throw e; }
                } throw e; 
            }
        }

        function setupUploadZone(id, callback) {
            const el = document.getElementById(id);
            if (!el) return;
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => {
                el.addEventListener(e, (ev) => { ev.preventDefault(); ev.stopPropagation(); });
            });
            ['dragenter', 'dragover'].forEach(e => el.addEventListener(e, () => el.classList.add('drag-over-zone')));
            ['dragleave', 'drop'].forEach(e => el.addEventListener(e, () => el.classList.remove('drag-over-zone')));
            el.addEventListener('drop', (e) => callback(e.dataTransfer.files));
        }

        // ================= MERGE LOGIC =================
        async function handleMergeFiles(fileList) {
            if (!fileList || fileList.length === 0) return;
            
            // å†æ¬¡æª¢æŸ¥ PDFLib æ˜¯å¦å¯ç”¨
            if (typeof PDFLib === 'undefined') {
                alert("æ ¸å¿ƒå°šæœªè¼‰å…¥å®Œæˆï¼Œè«‹ç¨å€™å†è©¦ã€‚");
                return;
            }

            document.getElementById('merge-ui-container').classList.remove('hidden');

            for (let i = 0; i < fileList.length; i++) {
                const file = fileList[i];
                if (file.type !== 'application/pdf' && !file.name.toLowerCase().endsWith('.pdf')) {
                    alert(`è·³éé PDF æª”æ¡ˆ: ${file.name}`);
                    continue;
                }
                const fileId = Date.now() + Math.random().toString(36).substr(2, 9);
                
                try {
                    let arrayBuffer = await file.arrayBuffer();
                    let pdfDoc;
                    
                    try {
                        pdfDoc = await smartLoadPdf(arrayBuffer.slice(0));
                        if (pdfDoc.isEncrypted) {
                            const decryptedBytes = await pdfDoc.save();
                            arrayBuffer = decryptedBytes.buffer; 
                            file.decryptedBlob = new Blob([decryptedBytes], { type: 'application/pdf' });
                        }
                    } catch (e) {
                        const pwd = prompt(`æª”æ¡ˆã€Œ${file.name}ã€éœ€è¦é–‹å•Ÿå¯†ç¢¼ï¼š`);
                        if (pwd) {
                            try {
                                pdfDoc = await smartLoadPdf(arrayBuffer.slice(0), pwd);
                                const decryptedBytes = await pdfDoc.save();
                                arrayBuffer = decryptedBytes.buffer; 
                                file.decryptedBlob = new Blob([decryptedBytes], { type: 'application/pdf' });
                            } catch { alert(`å¯†ç¢¼éŒ¯èª¤ï¼Œç•¥éã€Œ${file.name}ã€ã€‚`); continue; }
                        } else { continue; }
                    }

                    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer.slice(0) });
                    const pdfProxy = await loadingTask.promise;
                    const page = await pdfProxy.getPage(1);
                    const viewport = page.getViewport({ scale: 0.3 });
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    await page.render({ canvasContext: ctx, viewport: viewport }).promise;

                    const indices = Array.from({ length: pdfProxy.numPages }, (_, k) => k);
                    mergeFiles.push({
                        id: fileId, file: file, name: file.name,
                        originalPageCount: pdfProxy.numPages, pageIndices: indices,
                        thumbnail: canvas.toDataURL(), blob: file.decryptedBlob || null 
                    });
                } catch (err) { 
                    console.error("Load failed:", err); 
                    alert(`ç„¡æ³•è¼‰å…¥æª”æ¡ˆ ${file.name}: ${err.message}`);
                }
            }
            document.getElementById('merge-input').value = '';
            renderMergeList();
        }

        function renderMergeList() {
            const listEl = document.getElementById('file-list');
            document.getElementById('file-count').innerText = mergeFiles.length;
            listEl.innerHTML = '';
            mergeFiles.forEach((item, displayIndex) => {
                const el = document.createElement('div');
                el.className = "draggable-item bg-white border border-slate-200 rounded-lg p-3 flex items-center gap-4 relative shadow-sm hover:shadow-md cursor-pointer group select-none";
                el.draggable = true;
                el.ondblclick = () => openPageEditor(item.id);
                el.title = "é›™æ“Šå…©ä¸‹ä»¥ç·¨è¼¯é é¢";
                el.innerHTML = `<div class="cursor-move text-slate-300 hover:text-slate-500 px-1"><i class="fas fa-grip-vertical"></i></div><div class="relative pointer-events-none"><img src="${item.thumbnail}" class="w-16 h-20 object-contain bg-slate-50 border rounded shadow-sm"></div><div class="flex-1 min-w-0 pointer-events-none"><h4 class="text-sm font-bold text-slate-700 truncate">${item.name}</h4><p class="text-xs text-slate-500 mt-1">å« <span class="font-bold text-blue-600 bg-blue-50 px-1 rounded">${item.pageIndices.length}</span> é </p></div><button onclick="removeFile('${item.id}')" class="text-slate-400 hover:text-red-500 p-2 transition z-10"><i class="fas fa-trash-alt"></i></button>`;
                el.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/type', 'file_item'); e.dataTransfer.setData('text/index', displayIndex); el.classList.add('dragging-source'); });
                el.addEventListener('dragover', (e) => { e.preventDefault(); el.classList.add('drag-target-hover'); });
                el.addEventListener('dragleave', () => { el.classList.remove('drag-target-hover'); });
                el.addEventListener('drop', (e) => { e.preventDefault(); el.classList.remove('drag-target-hover'); if (e.dataTransfer.getData('text/type') !== 'file_item') return; const fi = parseInt(e.dataTransfer.getData('text/index')); const ti = displayIndex; if (fi !== ti && !isNaN(fi)) { const m = mergeFiles[fi]; mergeFiles.splice(fi, 1); mergeFiles.splice(ti, 0, m); renderMergeList(); } });
                el.addEventListener('dragend', () => { el.classList.remove('dragging-source'); document.querySelectorAll('.drag-target-hover').forEach(i => i.classList.remove('drag-target-hover')); });
                listEl.appendChild(el);
            });
            updateMergeBtnState();
        }

        function removeFile(id) { mergeFiles = mergeFiles.filter(f => f.id !== id); renderMergeList(); }

        async function openPageEditor(fileId) {
            const fileObj = mergeFiles.find(f => f.id === fileId);
            if (!fileObj) return;
            currentEditingFileId = fileId;
            editorPagesData = []; 
            editorDragCounter = 0;
            document.getElementById('editor-drop-overlay').classList.add('hidden');
            const modal = document.getElementById('page-editor-modal');
            const grid = document.getElementById('page-grid');
            const loader = document.getElementById('editor-loading');
            document.getElementById('editor-filename').innerText = fileObj.name;
            modal.classList.remove('hidden');
            grid.innerHTML = ''; 
            loader.classList.remove('hidden');
            document.getElementById('editor-loading-text').innerText = "è®€å–çµæ§‹ä¸­...";
            renderSidebarList();
            try {
                const arrayBuffer = await getFileArrayBuffer(fileObj);
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer.slice(0) }).promise;
                for (let i = 0; i < fileObj.pageIndices.length; i++) {
                    const originalIndex = fileObj.pageIndices[i];
                    editorPagesData.push({ fileId: fileId, pageIndex: originalIndex, imgSrc: null, status: 'pending' });
                }
                renderEditorGrid(); 
            } catch(e) { console.error(e); alert("ç„¡æ³•è®€å–é é¢"); } finally { loader.classList.add('hidden'); }
        }

        function renderEditorGrid() {
            const grid = document.getElementById('page-grid');
            grid.innerHTML = ''; 
            editorPagesData.forEach((pageData, displayIndex) => {
                const div = document.createElement('div');
                div.className = "page-card bg-white p-2 rounded shadow border border-gray-200 relative group select-none transition-transform";
                div.draggable = true;
                let imgContent = (pageData.status === 'loaded' && pageData.imgSrc) ? `<img src="${pageData.imgSrc}" class="w-full h-full object-contain">` : `<div class="w-full h-full bg-slate-100 flex items-center justify-center text-slate-300 lazy-placeholder" data-idx="${displayIndex}"><i class="fas fa-spinner fa-spin"></i></div>`;
                div.innerHTML = `<div class="absolute top-1 right-1 z-10"><button onclick="removePageInEditor(${displayIndex})" class="bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center shadow hover:bg-red-600 transition text-xs"><i class="fas fa-times"></i></button></div><div class="w-full aspect-[1/1.4] bg-gray-100 mb-2 overflow-hidden rounded border border-gray-100 pointer-events-none">${imgContent}</div><div class="text-center text-xs text-gray-400 font-mono">åŸå§‹ ${pageData.pageIndex + 1}</div>`;
                div.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/type', 'page_item'); e.dataTransfer.setData('text/index', displayIndex); div.classList.add('dragging-source'); isDraggingPage = true; });
                div.addEventListener('dragover', (e) => { e.preventDefault(); if (e.dataTransfer.getData('application/x-nuvex-file-id')) div.classList.add('sidebar-insert-hover'); else div.classList.add('drag-target-hover'); });
                div.addEventListener('dragleave', () => { div.classList.remove('drag-target-hover'); div.classList.remove('sidebar-insert-hover'); });
                div.addEventListener('drop', async (e) => { e.preventDefault(); div.classList.remove('drag-target-hover'); div.classList.remove('sidebar-insert-hover'); isDraggingPage = false; const sid = e.dataTransfer.getData('application/x-nuvex-file-id'); if (sid) { e.stopPropagation(); await handleSidebarFileDrop(sid, displayIndex); return; } if(e.dataTransfer.getData('text/type') !== 'page_item') return; const fi = parseInt(e.dataTransfer.getData('text/index')); const ti = displayIndex; if (fi !== ti && !isNaN(fi)) { const item = editorPagesData[fi]; editorPagesData.splice(fi, 1); editorPagesData.splice(ti, 0, item); renderEditorGrid(); } });
                div.addEventListener('dragend', () => { div.classList.remove('dragging-source'); document.querySelectorAll('.drag-target-hover, .sidebar-insert-hover').forEach(x => x.classList.remove(x.classList[x.length-1])); isDraggingPage = false; });
                grid.appendChild(div);
                if (pageData.status === 'pending') { const p = div.querySelector('.lazy-placeholder'); if(p && imageObserver) imageObserver.observe(p); }
            });
            document.getElementById('editor-page-count').innerText = editorPagesData.length;
        }

        async function loadPageThumbnail(idx, imgElement) {
            const data = editorPagesData[idx];
            if (!data || data.status === 'loaded') return;
            try {
                const fileObj = mergeFiles.find(f => f.id === data.fileId);
                if(!fileObj) return;
                const ab = await getFileArrayBuffer(fileObj);
                const loadingTask = pdfjsLib.getDocument({ data: ab.slice(0) });
                const pdf = await loadingTask.promise;
                const page = await pdf.getPage(data.pageIndex + 1);
                const viewport = page.getViewport({ scale: 0.3 });
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                await page.render({ canvasContext: canvas.getContext('2d'), viewport: viewport }).promise;
                data.imgSrc = canvas.toDataURL();
                data.status = 'loaded';
                if (imgElement && imgElement.parentNode) imgElement.parentNode.innerHTML = `<img src="${data.imgSrc}" class="w-full h-full object-contain">`;
            } catch (e) { console.error("Thumbnail failed", e); }
        }

        function removePageInEditor(index) { editorPagesData.splice(index, 1); renderEditorGrid(); }

        async function handleSidebarFileDrop(fileId, insertAtIndex = -1) {
            const fileObj = mergeFiles.find(f => f.id === fileId);
            if (!fileObj) return;
            const loader = document.getElementById('editor-loading');
            loader.classList.remove('hidden');
            try {
                const ab = await getFileArrayBuffer(fileObj);
                const pdf = await pdfjsLib.getDocument({ data: ab.slice(0) }).promise;
                const newPages = [];
                for (let i = 1; i <= pdf.numPages; i++) { newPages.push({ fileId: fileId, pageIndex: i - 1, imgSrc: null, status: 'pending' }); }
                if (insertAtIndex >= 0) editorPagesData.splice(insertAtIndex, 0, ...newPages);
                else editorPagesData.push(...newPages);
                renderEditorGrid();
            } catch(e) { alert("åŒ¯å…¥å¤±æ•—: " + e.message); } finally { loader.classList.add('hidden'); }
        }

        async function handleExternalFileDropInEditor(files, insertAtIndex = -1) {
            const loader = document.getElementById('editor-loading');
            loader.classList.remove('hidden');
            try {
                let hasPDF = false; const newItems = [];
                for (const file of files) {
                    if (file.type !== 'application/pdf' && !file.name.toLowerCase().endsWith('.pdf')) continue;
                    hasPDF = true;
                    const fileId = Date.now() + Math.random().toString(36).substr(2, 9);
                    let ab = await file.arrayBuffer();
                    let decryptedBlob = null;
                    try {
                        const pdfDoc = await smartLoadPdf(ab.slice(0));
                        if (pdfDoc.isEncrypted) {
                            const decryptedBytes = await pdfDoc.save();
                            ab = decryptedBytes.buffer;
                            decryptedBlob = new Blob([decryptedBytes], { type: 'application/pdf' });
                        }
                    } catch(e) {
                        const pwd = prompt(`æª”æ¡ˆã€Œ${file.name}ã€å·²åŠ å¯†ï¼Œè«‹è¼¸å…¥å¯†ç¢¼ä»¥æ’å…¥ï¼š`);
                        if (pwd) {
                            try {
                                const pdfDoc = await smartLoadPdf(ab.slice(0), pwd);
                                const decryptedBytes = await pdfDoc.save();
                                decryptedBlob = new Blob([decryptedBytes], { type: 'application/pdf' });
                                ab = decryptedBytes.buffer; 
                            } catch { alert("å¯†ç¢¼éŒ¯èª¤"); continue; }
                        } else continue; 
                    }
                    const loadingTask = pdfjsLib.getDocument({ data: ab.slice(0) });
                    const pdf = await loadingTask.promise;
                    const p1 = await pdf.getPage(1);
                    const v = p1.getViewport({ scale: 0.3 });
                    const c = document.createElement('canvas'); c.width = v.width; c.height = v.height;
                    await p1.render({ canvasContext: c.getContext('2d'), viewport: v }).promise;
                    const fObj = { id: fileId, file: file, name: file.name, originalPageCount: pdf.numPages, pageIndices: Array.from({length: pdf.numPages},(_,k)=>k), thumbnail: c.toDataURL(), blob: decryptedBlob };
                    mergeFiles.push(fObj);
                    for(let i=0; i<pdf.numPages; i++) newItems.push({ fileId: fileId, pageIndex: i, imgSrc: null, status: 'pending' });
                }
                if (newItems.length > 0) {
                    if (insertAtIndex >= 0) editorPagesData.splice(insertAtIndex, 0, ...newItems);
                    else editorPagesData.push(...newItems);
                    renderEditorGrid(); renderSidebarList();
                }
            } catch(e) { console.error(e); } finally { loader.classList.add('hidden'); }
        }

        function renderSidebarList() {
            const sidebar = document.getElementById('sidebar-file-list');
            sidebar.innerHTML = '';
            const otherFiles = mergeFiles.filter(f => f.id !== currentEditingFileId);
            if (otherFiles.length === 0) { sidebar.innerHTML = '<div class="text-center text-gray-400 text-xs py-10">æ²’æœ‰å…¶ä»–æª”æ¡ˆ</div>'; return; }
            otherFiles.forEach(file => {
                const item = document.createElement('div');
                item.className = "sidebar-item bg-white border border-gray-200 p-2 rounded shadow-sm hover:shadow-md flex items-center gap-2 transition";
                item.draggable = true;
                item.innerHTML = `<div class="text-gray-300 cursor-grab px-1"><i class="fas fa-grip-vertical"></i></div><img src="${file.thumbnail}" class="w-8 h-10 object-contain bg-gray-50 border rounded pointer-events-none"><div class="flex-1 min-w-0 pointer-events-none"><div class="text-xs font-bold text-gray-700 truncate">${file.name}</div><div class="text-[10px] text-gray-400">${file.pageIndices.length} é </div></div>`;
                item.addEventListener('dragstart', (e) => { e.dataTransfer.setData('application/x-nuvex-file-id', file.id); e.dataTransfer.setData('application/x-nuvex-sort-id', file.id); e.dataTransfer.effectAllowed = 'copyMove'; item.style.opacity = '0.5'; });
                item.addEventListener('dragend', () => item.style.opacity = '1');
                item.addEventListener('dragover', (e) => { e.preventDefault(); item.classList.add('sidebar-target-hover'); });
                item.addEventListener('dragleave', () => item.classList.remove('sidebar-target-hover'));
                item.addEventListener('drop', (e) => {
                    e.preventDefault(); item.classList.remove('sidebar-target-hover');
                    const sid = e.dataTransfer.getData('application/x-nuvex-sort-id');
                    if (sid && sid !== file.id) {
                        const fi = mergeFiles.findIndex(x => x.id === sid);
                        const ti = mergeFiles.findIndex(x => x.id === file.id);
                        if (fi > -1 && ti > -1) { const mv = mergeFiles[fi]; mergeFiles.splice(fi, 1); mergeFiles.splice(ti, 0, mv); renderSidebarList(); renderMergeList(); }
                    }
                });
                sidebar.appendChild(item);
            });
        }

        async function saveEditorChanges() {
            const fileObj = mergeFiles.find(f => f.id === currentEditingFileId);
            if (!fileObj) return;
            const btn = document.getElementById('btn-save-editor');
            const ot = btn.innerHTML;
            btn.innerHTML = '<div class="loader mr-2 w-4 h-4"></div> è™•ç†ä¸­...'; btn.disabled = true;
            try {
                const { PDFDocument } = PDFLib;
                const newPdf = await PDFDocument.create();
                const loadedSourcePdfs = new Map();
                for (const pData of editorPagesData) {
                    let srcPdf = loadedSourcePdfs.get(pData.fileId);
                    if (!srcPdf) {
                        const sourceFileObj = mergeFiles.find(f => f.id === pData.fileId);
                        if (!sourceFileObj) continue; 
                        const ab = await getFileArrayBuffer(sourceFileObj);
                        srcPdf = await smartLoadPdf(ab);
                        loadedSourcePdfs.set(pData.fileId, srcPdf);
                    }
                    const [copiedPage] = await newPdf.copyPages(srcPdf, [pData.pageIndex]);
                    newPdf.addPage(copiedPage);
                }
                const pdfBytes = await newPdf.save();
                const newBlob = new Blob([pdfBytes], { type: 'application/pdf' });
                fileObj.blob = newBlob; 
                fileObj.originalPageCount = editorPagesData.length;
                fileObj.pageIndices = Array.from({ length: editorPagesData.length }, (_, k) => k);
                if (editorPagesData.length > 0) fileObj.thumbnail = editorPagesData[0].imgSrc;
                closeEditor(); renderMergeList();
            } catch (err) { console.error(err); alert("å„²å­˜å¤±æ•—ï¼š" + err.message); } finally { btn.innerHTML = ot; btn.disabled = false; }
        }

        function setupEditorDropZone() {
            const container = document.getElementById('page-editor-modal'); 
            const overlay = document.getElementById('editor-drop-overlay');
            container.addEventListener('dragenter', (e) => { if (e.dataTransfer.types.includes('Files')) { e.preventDefault(); editorDragCounter++; if (editorDragCounter===1) overlay.classList.remove('hidden'); } });
            container.addEventListener('dragleave', (e) => { if (e.dataTransfer.types.includes('Files')) { e.preventDefault(); editorDragCounter--; if (editorDragCounter<=0) { editorDragCounter=0; overlay.classList.add('hidden'); } } });
            container.addEventListener('dragover', (e) => { if (e.dataTransfer.types.includes('Files')) e.preventDefault(); });
            container.addEventListener('drop', async (e) => {
                if (e.dataTransfer.files?.length > 0) { e.preventDefault(); editorDragCounter=0; overlay.classList.add('hidden'); await handleExternalFileDropInEditor(e.dataTransfer.files); return; }
            });
        }

        function closeEditor() {
            document.getElementById('page-editor-modal')ã€‚classListã€‚add('hidden');
            document.getElementById('editor-drop-overlay').classList.add('hidden');
            editorDragCounter = 0; currentEditingFileId = null; editorPagesData = []; 
            if (imageObserver) imageObserverã€‚disconnect();
            renderMergeList();
        }

        function updateMergeBtnState() {
            const btn = documentã€‚getElementById('btn-merge');
            if (mergeFilesã€‚length < 1) { btnã€‚disabled = true; btnã€‚classListã€‚add('opacity-50'ï¼Œ 'cursor-not-allowed'); btnã€‚innerHTML = '<span>è«‹å…ˆä¸Šå‚³æª”æ¡ˆ</span>'; }
            else { btnã€‚disabled = false; btnã€‚classListã€‚remove('opacity-50'ï¼Œ 'cursor-not-allowed'); btnã€‚innerHTML = '<span>é–‹å§‹åˆä½µ PDF</span>'; }
        }

        async function executeMerge() {
            if (mergeFilesã€‚length < 1) return;
            const btn = document.getElementById('btn-merge'), ot = btn.innerHTML;
            btnã€‚innerHTML = '<div class="loader mr-2"></div> è™•ç†ä¸­...'; btnã€‚disabled = true;
            try {
                const { PDFDocument } = PDFLib;
                const mp = await PDFDocumentã€‚create();
                for (const it of mergeFiles) {
                    if (!it.pageIndices.length) continue;
                    const ab = await getFileArrayBuffer(it);
                    const p = await smartLoadPdf(ab);
                    const cp = await mp.copyPages(p, it.pageIndices); cp.forEach(x => mp.addPage(x));
                }
                const u = URL.createObjectURL(new Blob([await mp.save()], { type: 'application/pdf' }));
                const n = new Date()ï¼Œ pad = (n) => String(n)ã€‚padStart(2ï¼Œ '0');
                const fn = `NuvexPDF_${n.getFullYear()}${pad(n.getMonth()+1)}${pad(n.getDate())}${pad(n.getHours())}${pad(n.getMinutes())}.pdf`;
                const dl = document.getElementById('merge-download'); dl.href = u; dl.download = fn;
                btnã€‚classListã€‚add('hidden'); dlã€‚classListã€‚remove('hidden');
            } catch (e) { alert(e.message || "åˆä½µå¤±æ•—"); } 
            finally { if (documentã€‚getElementById('merge-download')ã€‚classListã€‚contains('hidden')) { btnã€‚innerHTML = ot; btn.disabled = false; } }
        }

        function initAutoScroll() {
            const container = document.getElementById('modal-scroll-container');
            document.addEventListener('dragover', (e) => { if (isDraggingPage) currentMouseY = e.clientY; });
            function loop() {
                if (isDraggingPage) {
                    const rect = container.getBoundingClientRect();
                    if (currentMouseY > 0) {
                        if (currentMouseY < rect.top + 100) container.scrollTop -= 15;
                        else if (currentMouseY > rect.bottom - 100) container.scrollTop += 15;
                    }
                } scrollAnimationId = requestAnimationFrame(loop);
            } scrollAnimationId = requestAnimationFrame(loop);
        }
    </script>
</body>
</html>
